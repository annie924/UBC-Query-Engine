import { InsightError } from "../controller/IInsightFacade";

export default class ValidateQuery {
	public static validQuery(query: any): string {
		if (typeof query !== "object" || query === null) {
			throw new InsightError("Query must be an object.");
		}

		if (!("WHERE" in query) || !("OPTIONS" in query)) {
			throw new InsightError("Query must contain WHERE, OPTIONS and TRANSFORMATIONS.");
		}

		if (typeof query.WHERE !== "object" || query.WHERE === null || Array.isArray(query.WHERE)) {
			throw new InsightError("WHERE must be an object.");
		}

		if (typeof query.OPTIONS !== "object" || query.OPTIONS === null || Array.isArray(query.OPTIONS)) {
			throw new InsightError("OPTIONS must be an object.");
		}

		let applyKeys = new Set<string>();
		let groupKeys = new Set<string>();
		let datasetId: string;

		if ("TRANSFORMATIONS" in query) {
			datasetId = ValidateQuery.extractDatasetId(query.OPTIONS.COLUMNS, query.TRANSFORMATIONS);
			applyKeys = ValidateQuery.validTrans(query.TRANSFORMATIONS, datasetId);
			groupKeys = new Set(query.TRANSFORMATIONS.GROUP);
			ValidateQuery.validOption(query.OPTIONS, datasetId, applyKeys, groupKeys);
		} else {
			datasetId = ValidateQuery.extractDatasetId(query.OPTIONS.COLUMNS);
			ValidateQuery.validOption(query.OPTIONS, datasetId, applyKeys);
		}
		ValidateQuery.validWhere(query.WHERE, datasetId);

		return datasetId;
	}

	/**
	 * BEGIN AI-GENERATED CODE
	 * Generated by ChatGPT (OpenAI) on 2025-02-02.
	 * Purpose: Implements validation
	 * Modified by Annie
	 */
	private static validOption(options: any, datasetId: string, applyKeys: Set<string>, groupKeys?: Set<string>): void {
		if (!("COLUMNS" in options) || !Array.isArray(options.COLUMNS) || options.COLUMNS.length === 0) {
			throw new InsightError("OPTIONS must have a non-empty COLUMNS array.");
		}

		for (const col of options.COLUMNS) {
			if (!col.includes("_")) {
				if (!applyKeys.has(col)) {
					throw new InsightError(`Invalid column key: "${col}". Must be a dataset key or an APPLY key.`);
				}
			} else {
				ValidateQuery.validateKeyFormat(col, datasetId, "COLUMN");
				if (groupKeys && !groupKeys.has(col)) {
					throw new InsightError(`Column "${col}" must be in GROUP or APPLY when using TRANSFORMATIONS.`);
				}
			}

			if (typeof col !== "string") {
				throw new InsightError("Each column in COLUMNS must be a string.");
			}
		}

		if ("ORDER" in options) {
			ValidateQuery.validOrder(options.ORDER, options.COLUMNS);
		}
	}

	public static validOrder(order: any, columns: string[]): void {
		if (typeof order === "string") {
			if (!columns.includes(order)) {
				throw new InsightError("ORDER must be a column from COLUMNS.");
			}
		} else if (typeof order === "object" && order !== null) {
			if (!("dir" in order) || !["UP", "DOWN"].includes(order.dir)) {
				throw new InsightError(`ORDER direction must be "UP" or "DOWN".`);
			}

			if (!("keys" in order) || !Array.isArray(order.keys) || order.keys.length === 0) {
				throw new InsightError(`ORDER keys must be a non-empty array.`);
			}

			for (const key of order.keys) {
				if (!columns.includes(key)) {
					throw new InsightError(`ORDER key "${key}" must exist in COLUMNS.`);
				}
			}
		} else {
			throw new InsightError("ORDER must be either a string or an object.");
		}
	}

	public static validWhere(where: any, datasetId: string): void {
		const keys = Object.keys(where);

		if (keys.length === 0) {
			return;
		}

		if (keys.length > 1) {
			throw new InsightError("WHERE must contain one filter or no filter.");
		}

		const filterType = keys[0];

		if (["AND", "OR"].includes(filterType)) {
			if (!Array.isArray(where[filterType]) || where[filterType].length === 0) {
				throw new InsightError(`${filterType} must be a non-empty array.`);
			}
			where[filterType].forEach((subCondition: any) => ValidateQuery.validWhere(subCondition, datasetId));
		} else if (["GT", "LT", "EQ"].includes(filterType)) {
			this.validMComparator(where, filterType, datasetId);
		} else if (filterType === "NOT") {
			if (typeof where[filterType] !== "object" || where[filterType] === null) {
				throw new InsightError(`${filterType} must be object.`);
			}
			// if (Array.isArray(where[filterType])) {
			// 	throw new InsightError(`${filterType} must be object.`);
			// }
			ValidateQuery.validWhere(where[filterType], datasetId);
		} else if (filterType === "IS") {
			this.validIs(where, filterType, datasetId);
		} else {
			throw new InsightError(`Invalid WHERE filter: ${filterType}`);
		}
	}

	private static validIs(where: any, filterType: string, datasetId: string): void {
		const filterObject = where[filterType];
		// if (Array.isArray(filterObject)) {
		// 	throw new InsightError(`${filterType} must be object.`);
		// }
		if (typeof filterObject !== "object" || filterObject === null || Object.keys(filterObject).length !== 1) {
			throw new InsightError(`${filterType} must have exactly one key-value pair.`);
		}

		const key = Object.keys(filterObject)[0];
		ValidateQuery.validateKeyFormat(key, datasetId, "WHERE");

		const value = filterObject[key];
		if (typeof value !== "string") {
			throw new InsightError(`${filterType} value must be a string.`);
		}

		if (!ValidateQuery.validWildcard(value)) {
			throw new InsightError(`${filterType} value must contain '*' only at the start or end.`);
		}
	}

	private static validWildcard(value: string): boolean {
		return /^(\*?[^\*]*\*?)$/.test(value);
	}

	private static validMComparator(where: any, filterType: string, datasetId: string): void {
		const filterObject = where[filterType];
		if (typeof filterObject !== "object" || Object.keys(filterObject).length !== 1) {
			throw new InsightError(`${filterType} must have exactly one key-value pair.`);
		}

		const key = Object.keys(filterObject)[0];
		ValidateQuery.validateKeyFormat(key, datasetId, "WHERE");

		const value = filterObject[key];
		if (typeof value !== "number") {
			throw new InsightError(`${filterType} value must be a number.`);
		}
	}

	/**
	 * END AI-GENERATED CODE
	 */

	public static validTrans(trans: any, datasetId: string): Set<string> {
		if (typeof trans !== "object" || trans === null) {
			throw new InsightError("TRANSFORMATIONS must be an object.");
		}

		if (!("GROUP" in trans) || !("APPLY" in trans)) {
			throw new InsightError("TRANSFORMATIONS must contain GROUP and APPLY.");
		}

		if (!Array.isArray(trans.GROUP) || trans.GROUP.length === 0) {
			throw new InsightError("GROUP must be a non-empty array.");
		}

		if (!Array.isArray(trans.APPLY)) {
			throw new InsightError("APPLY must be an array.");
		}

		ValidateQuery.validGroup(trans.GROUP, datasetId);
		return ValidateQuery.validApply(trans.APPLY, datasetId);
	}

	private static validGroup(group: any, datasetId: string): void {
		for (const key of group) {
			ValidateQuery.validateKeyFormat(key, datasetId, "GROUP");
		}
	}

	/**
	 * BEGIN AI-GENERATED CODE
	 * Generated by ChatGPT (OpenAI) on 2025-03-02.
	 * Purpose: Check the valid use of apply
	 * Modified by Annie
	 */
	private static validApply(apply: any, datasetId: string): Set<string> {
		const applyKeys = new Set<string>();

		// APPLYRULE ::= '{' applykey ': {' APPLYTOKEN ':' KEY '} }'
		for (const applyRule of apply) {
			if (typeof applyRule !== "object" || applyRule === null || Object.keys(applyRule).length !== 1) {
				throw new InsightError("Each APPLY rule must be an object with exactly one key.");
			}

			const applyKey = Object.keys(applyRule)[0];

			if (typeof applyKey !== "string" || applyKey.trim() === "") {
				throw new InsightError("APPLY key must be a non-empty string.");
			}

			if (applyKey.includes("_")) {
				throw new InsightError("APPLY key cannot contain underscore. ");
			}

			if (applyKeys.has(applyKey)) {
				throw new InsightError(`APPLY key "${applyKey}" already exists.`);
			}

			applyKeys.add(applyKey);

			const applyValue = applyRule[applyKey];
			ValidateQuery.validRule(applyValue, datasetId);
		}

		return applyKeys;
	}

	private static validRule(applyValue: any, datasetId: string): void {
		if (typeof applyValue !== "object" || applyValue === null || Object.keys(applyValue).length !== 1) {
			throw new InsightError("Each APPLY rule must map to an object.");
		}

		const operation = Object.keys(applyValue)[0];
		const validOperations = ["MAX", "MIN", "AVG", "SUM", "COUNT"];
		if (!validOperations.includes(operation)) {
			throw new InsightError(`Invalid APPLY operation: ${operation}.`);
		}

		const key = applyValue[operation];
		ValidateQuery.validateKeyFormat(key, datasetId, "APPLY");

		if (["MAX", "MIN", "AVG", "SUM"].includes(operation)) {
			const validNumericKeys = ["year", "avg", "pass", "fail", "audit", "seats", "lat", "lon"];
			const keyParts = key.split("_");
			if (!validNumericKeys.includes(keyParts[1])) {
				throw new InsightError(`Operation ${operation} can only be applied to numeric fields.`);
			}
		}
	}

	private static validateKeyFormat(key: string, datasetId: string, context: string): void {
		if (!key.includes("_")) {
			throw new InsightError(`Invalid ${context} key: "${key}". Must contain an underscore.`);
		}

		const parts = key.split("_");
		if (parts.length !== 2) {
			throw new InsightError(`Invalid ${context} key format: "${key}".`);
		}

		if (!key.startsWith(datasetId + "_")) {
			throw new InsightError(`${context} key "${key}" does not match dataset ID "${datasetId}".`);
		}
	}

	// helper function
	private static extractDatasetId(columns: string[], transformations?: any): string {
		if (!Array.isArray(columns)) {
			throw new InsightError("OPTIONS.COLUMNS must be a non-empty array.");
		}
		const datasetIds = new Set(
			columns
				.filter((col) => col.includes("_"))
				.map((col) => {
					const parts = col.split("_");
					if (parts.length < 2) {
						throw new InsightError(`Invalid column format: ${col}.`);
					}
					return parts[0]; // Extract datasetId
				})
		);

		if (datasetIds.size === 0 && transformations) {
			transformations.GROUP.forEach((key: string) => {
				if (key.includes("_")) {
					datasetIds.add(key.split("_")[0]);
				}
			});
		}

		if (datasetIds.size !== 1) {
			throw new InsightError("Query must reference a single dataset.");
		}

		return [...datasetIds][0];
	}

	/**
	 * END AI-GENERATED CODE
	 */
}
