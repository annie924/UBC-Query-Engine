import Section from "../Dataset/Section";
import Where, { Filter } from "../QueryModel/Where";
import Option from "../QueryModel/Option";
import { InsightError } from "../controller/IInsightFacade";
import Trans from "../QueryModel/Trans";
import Decimal from "decimal.js";

export default class ApplyFilter {
	/**
	 * BEGIN AI-GENERATED CODE
	 * Generated by ChatGPT (OpenAI) on 2025-03-03.
	 * Purpose: Implements part of the evaluation of where and options
	 * Modified by Annie
	 */

	public static applyWhere(entries: Section[], where: Where): Section[] {
		if (!where || Object.keys(where.filter).length === 0) {
			return entries;
		}

		return entries.filter((entry) => this.evaluateWhere(entry, where));
	}

	private static evaluateWhere(entry: Section, where: Where): boolean {
		const filterType = where.getFilterType();
		const value = where.getFilterValue();

		if (filterType === "AND") {
			const isArray = Array.isArray(value);
			return isArray && value.every((condition: Filter) => this.evaluateWhere(entry, new Where(condition)));
		}
		if (filterType === "OR") {
			const isArray = Array.isArray(value);
			return isArray && value.some((condition: Filter) => this.evaluateWhere(entry, new Where(condition)));
		}

		if (["GT", "LT", "EQ"].includes(filterType)) {
			return this.compareValues(entry, filterType, value);
		}
		if (filterType === "IS") {
			return this.compareStrings(entry, value);
		}
		if (filterType === "NOT") {
			return !this.evaluateWhere(entry, new Where(value));
		}
		throw new InsightError(`Invalid WHERE filter type: ${filterType}`);
	}

	private static compareValues(entry: any, operator: string, condition: { [key: string]: number }): boolean {
		const fieldWithDataset = Object.keys(condition)[0];
		const targetValue = condition[fieldWithDataset];

		const field = fieldWithDataset.includes("_") ? fieldWithDataset.split("_")[1] : fieldWithDataset;

		if (!(field in entry) || typeof entry[field] !== "number") {
			return false;
		}

		if (operator === "GT") return entry[field] > targetValue;
		if (operator === "LT") return entry[field] < targetValue;
		if (operator === "EQ") return entry[field] === targetValue;

		return false;
	}

	private static compareStrings(entry: any, condition: { [key: string]: string }): boolean {
		const fieldWithDataset = Object.keys(condition)[0];
		const targetValue = condition[fieldWithDataset];

		const field = fieldWithDataset.includes("_") ? fieldWithDataset.split("_")[1] : fieldWithDataset;

		if (!(field in entry) || typeof entry[field] !== "string") {
			return false;
		}

		return this.matchesWildcard(entry[field], targetValue);
	}

	private static matchesWildcard(value: string, pattern: string): boolean {
		const regexPattern = `^${pattern.replace(/\*/g, ".*")}$`;
		return new RegExp(regexPattern).test(value);
	}

	public static applyOptions(entries: any[], option: Option): Partial<any>[] {
		const columnMappings = option.column.map((col) => ({
			original: col,
			normalized: col.includes("_") ? col.split("_")[1] : col,
		}));

		const results = entries.map((entry) => {
			const newObj: Record<string, string | number | undefined> = {};

			columnMappings.forEach(({ original, normalized }) => {
				if (!(original in entry) && !(normalized in entry)) {
					throw new InsightError(`Field "${original}" does not exist in the dataset.`);
				}
				newObj[original] = entry[original] ?? entry[normalized];
			});

			return newObj;
		});

		// Sorting logic
		if (option.order) {
			ApplyFilter.sortResults(results, option.order);
		}

		return results;
	}

	private static sortResults(results: any[], order: string | { dir: "UP" | "DOWN"; keys: string[] }): void {
		if (typeof order === "string") {
			results.sort((a, b) => ApplyFilter.compareSort(a[order], b[order], "UP"));
		} else {
			results.sort((a, b) => {
				for (const key of order.keys) {
					const comparison = ApplyFilter.compareSort(a[key], b[key], order.dir);
					if (comparison !== 0) {
						return comparison;
					}
				}
				return 0;
			});
		}
	}

	private static compareSort(a: any, b: any, dir: "UP" | "DOWN"): number {
		if (a === undefined) return 1;
		if (b === undefined) return -1;

		if (typeof a === "number" && typeof b === "number") {
			return dir === "UP" ? a - b : b - a;
		}

		if (typeof a === "string" && typeof b === "string") {
			return dir === "UP" ? (a < b ? -1 : a > b ? 1 : 0) : a > b ? -1 : a < b ? 1 : 0;
		}

		return 0;
	}

	public static applyTrans(entries: any[], transformations: Trans): any[] {
		const groupKeys = transformations.group;
		const extractKeys = groupKeys.map((key) => key.split("_")[1]);
		const groupedData = ApplyFilter.groupEntries(entries, extractKeys);
		return ApplyFilter.applyAggregations(groupedData, transformations.apply, groupKeys);
	}

	private static groupEntries(entries: any[], groupKeys: string[]): Map<string, any[]> {
		const groupedMap = new Map<string, any[]>();

		for (const entry of entries) {
			const groupKeyValues = groupKeys.map((key: string) => {
				return entry[key] !== undefined ? entry[key] : "MISSING";
			});

			const groupKey: string = groupKeyValues.join("|");

			if (!groupedMap.has(groupKey)) {
				groupedMap.set(groupKey, []);
			}
			groupedMap.get(groupKey)?.push(entry);
		}

		return groupedMap;
	}

	private static applyAggregations(groupedData: Map<string, any[]>, applyRules: any[], groupKeys: string[]): any[] {
		const result: any[] = [];

		for (const [groupKey, groupEntries] of groupedData.entries()) {
			const transformedEntry: any = {};

			const keyValues = groupKey.split("|");
			groupKeys.forEach((key, index) => {
				transformedEntry[key] = keyValues[index];
			});

			for (const applyRule of applyRules) {
				const applyKey = Object.keys(applyRule)[0];
				const operation = Object.keys(applyRule[applyKey])[0];
				const fieldKey = applyRule[applyKey][operation].split("_")[1];

				transformedEntry[applyKey] = ApplyFilter.computeAggregation(operation, fieldKey, groupEntries);
			}

			result.push(transformedEntry);
		}

		return result;
	}

	private static computeAggregation(operation: string, targetKey: string, groupEntries: any[]): number {
		const values = groupEntries.map((entry) => entry[targetKey]);

		switch (operation) {
			case "MAX":
				return values.length > 0 ? Math.max(...values) : 0;
			case "MIN":
				return values.length > 0 ? Math.min(...values) : 0;
			case "AVG":
				if (values.length === 0) return 0;
				const total = this.sumValues(values);
				const numRows = values.length;
				const avg = total.toNumber() / numRows;
				if (avg < 0) {
					throw new InsightError("out of range. ");
				}
				return Number(avg.toFixed(2));
			case "SUM":
				if (values.length === 0) return 0;
				const res = this.sumValues(values);
				if (res.toNumber() < 0) {
					throw new InsightError("out of range. ");
				}
				return Number(res.toFixed(2));
			case "COUNT":
				return new Set(values).size;
			default:
				throw new InsightError(`Invalid APPLY operation: ${operation}`);
		}
	}

	private static sumValues(values: number[]): Decimal {
		let total = new Decimal(0);

		for (const val of values) {
			const decimalVal = new Decimal(val);
			total = total.add(decimalVal);
		}

		return total;
	}

	/**
	 * END AI-GENERATED CODE
	 */
}
